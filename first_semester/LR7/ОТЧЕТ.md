Выполнил *Рябков Александр, 504764. Группа P3124*

Содержание
1. Декоратор logger
2. Функция get_currencies
3. Демо: квадратное уравнение
4. Примеры логов
5. Тестирование (get_currencies, декоратора, StringIO, демо, логирование)

# Декоратор logger


```python
def logger(func: Callable = None, *, handle=sys.stdout): # type: ignore

    """
    Универсальный декоратор для логирования.
    Использование:
    1. @logger  # handle=sys.stdout по умолчанию
    2. @logger()  # тоже handle=sys.stdout
    3. @logger(handle=sys.stderr)  # в stderr
    4. @logger(handle=io.StringIO())  # в строковый буфер
    5. @logger(handle=logging.getLogger("name"))  # в логгер
    """

    if func is None:
        return lambda f: logger(f, handle=handle)

    @functools.wraps(func)
    def inner(*args, **kwargs) -> Any:
        # Определяем способ логирования
        if isinstance(handle, logging.Logger):
            # Используем методы логгера с разными уровнями
            def log(level, msg):
                if level == 'INFO':
                    handle.info(msg) # type: ignore
                elif level == 'WARNING':
                    handle.warning(msg) # type: ignore
                elif level == 'ERROR':
                    handle.error(msg) # type: ignore
                elif level == 'CRITICAL':
                    handle.critical(msg) # type: ignore
                else:
                    handle.info(msg)  # type: ignore # по умолчанию
        else:
            # Для потока пишем с префиксом уровня
            def log(level, msg):
                handle.write(f"{level}: {msg}\n")
                if hasattr(handle, 'flush'):
                    handle.flush()

        # Логируем начало вызова (INFO)
        log('INFO', f"Вызов функции {func.__name__} с args={args}, kwargs={kwargs}")

        try:
            # Вызываем оригинальную функцию
            result = func(*args, **kwargs)
            # Логируем успешное завершение (INFO)
            log('INFO', f"Функция {func.__name__} завершилась успешно. Результат: {result}")

            return result

        except Exception as e:
            # Определяем уровень для ошибки по содержимому сообщения
            error_msg = str(e)
            if 'CRITICAL' in error_msg.upper():
                level = 'CRITICAL'
            elif 'WARNING' in error_msg.upper():
                level = 'WARNING'
            else:
                level = 'ERROR'
            # Логируем ошибку
            log(level, f"Функция {func.__name__} вызвала исключение {type(e).__name__}: {error_msg}")

            raise

    return inner
```

# Функция get_currencies

```python
import requests
from typing import List, Dict

def get_currencies(
    currency_codes: List[str], 
    url: str = "https://www.cbr-xml-daily.ru/daily_json.js"
) -> Dict[str, float]:
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        raise ConnectionError(f"API недоступно: {e}")
    
    try:
        data = response.json()
    except ValueError as e:
        raise ValueError(f"Некорректный JSON: {e}")
    
    if "Valute" not in data:
        raise KeyError("Ключ 'Valute' отсутствует в данных API")
    
    result = {}
    for code in currency_codes:
        if code not in data["Valute"]:
            raise KeyError(f"Валюта '{code}' отсутствует в данных API")
        
        value = data["Valute"][code]["Value"]
        if not isinstance(value, (int, float)):
            raise TypeError(f"Курс валюты '{code}' имеет неверный тип: {type(value)}")
        
        result[code] = value
    
    return result
```

# Демо. Квадратное уравнение

```python

@logger
def solve_quadratic(a: float, b: float, c: float):
    # ERROR
    if not all(isinstance(x, (int, float)) for x in [a, b, c]):
        raise TypeError("ERROR: Коэффициенты должны быть числами")
    
    # CRITICAL
    if a == 0 and b == 0:
        raise ValueError("CRITICAL: Оба коэффициента a и b равны 0")
    
    if a == 0:
        return [-c / b]  # Линейное уравнение
    
    d = b**2 - 4*a*c
    
    # WARNING
    if d < 0:
        raise ValueError(f"WARNING: Дискриминант отрицательный: {d}")
    
    if d == 0:
        return [-b / (2*a)]
    
    sqrt_d = math.sqrt(d)
    return [(-b + sqrt_d) / (2*a), (-b - sqrt_d) / (2*a)]
```

# Примеры логов

```log
INFO: Вызов функции solve_quadratic с args=(1, -3, 2), kwargs={}
INFO: Функция solve_quadratic завершилась успешно. Результат: [2.0, 1.0]

WARNING: Вызов функции solve_quadratic с args=(1, 1, 1), kwargs={}
WARNING: Функция solve_quadratic вызвала исключение ValueError: WARNING: Дискриминант отрицательный: -3
```

# Тестирование

## Тесты функции get_currencies

```python
import unittest
from main import get_currencies, get_currencies_console
import io

class TestGetCurrenciesFunction(unittest.TestCase):
    """Тестирование функции get_currencies"""
    
    def test_correct_return_real_rates(self):
        """Корректный возврат реальных курсов"""
        result = get_currencies_console(['USD', 'EUR'])
        self.assertIn('USD', result)
        self.assertIn('EUR', result)
        self.assertIsInstance(result['USD'], (int, float))
        self.assertIsInstance(result['EUR'], (int, float))
    
    def test_behavior_nonexistent_currency(self):
        """Поведение при несуществующей валюте"""
        with self.assertRaises(KeyError):
            get_currencies_console(['XYZ'])
    
    def test_raise_connection_error(self):
        """Выброс ConnectionError при недоступном API"""
        with self.assertRaises(ConnectionError):
            get_currencies_console(['USD'], url="https://invalid-url.example.com")
    
    def test_raise_value_error(self):
        """Выброс ValueError при некорректном JSON"""
        # URL, возвращающий не JSON (например, HTML страницу)
        with self.assertRaises(ValueError):
            get_currencies_console(['USD'], url="https://httpbin.org/html")
    
    def test_raise_key_error(self):
        """Выброс KeyError при отсутствии валюты"""
        with self.assertRaises(KeyError):
            get_currencies_console(['XYZ'])
```

## Тесты декоратора

```python
class TestLoggerDecorator(unittest.TestCase):
    """Тестирование декоратора (логгера)"""
    
    def setUp(self):
        """Подготовка StringIO для тестов"""
        self.stream = io.StringIO()
        
    def test_logs_on_successful_execution(self):
        """Логи при успешном выполнении"""
        @logger(handle=self.stream)
        def test_function(x):
            return x * 2
        
        # Вызываем функцию
        result = test_function(5)
        # Проверяем результат
        self.assertEqual(result, 10)
        # Проверяем логи
        logs = self.stream.getvalue()
        
        # Сообщение о старте (INFO)
        self.assertIn("INFO", logs)
        self.assertIn("test_function", logs)
        self.assertIn("args=(5,)", logs)
        
        # Сообщение об окончании (INFO)
        self.assertIn("Результат: 10", logs)
        
        # Аргументы и возвращаемое значение записаны
        self.assertIn("args=(5,)", logs)
        self.assertIn("Результат: 10", logs)
    
    def test_logs_on_errors(self):
        """Логи при ошибках"""
        @logger(handle=self.stream)
        def error_function():
            raise ValueError("Тестовая ошибка")
        
        # Проверяем, что исключение пробрасывается
        with self.assertRaises(ValueError):
            error_function()
        
        # Проверяем логи через assertRegex (как в ТЗ)
        logs = self.stream.getvalue()
        self.assertRegex(logs, "ERROR")
        self.assertRegex(logs, "ValueError")
        self.assertRegex(logs, "Тестовая ошибка")
```

## Тесты работы с StringIO

```python
class TestStreamWrite(unittest.TestCase):
    """Пример теста с контекстом из задания"""
    def setUp(self):
        self.stream = io.StringIO()
        @logger(handle=self.stream)
        def wrapped():
            return get_currencies(['USD'], url="https://invalid")
        self.wrapped = wrapped

    def test_logging_error(self):
        """Проверяем логирование ошибки ConnectionError"""
        # Проверяем, что исключение пробрасывается
        with self.assertRaises(ConnectionError):
            self.wrapped()
            
        # Проверяем логи
        logs = self.stream.getvalue()
        self.assertIn("ERROR", logs)
        self.assertIn("ConnectionError", logs)
```

## Доп. тесты для квадратного уравнения

```python

class TestQuadraticEquation(unittest.TestCase):
    """Тесты демо квадратного уравнения"""
    
    def test_info_two_roots(self):
        """INFO для двух корней"""
        result = solve_quadratic(1, -3, 2)  # (x-1)(x-2)=0
        self.assertEqual(sorted(result), [1.0, 2.0])
    
    def test_warning_negative_discriminant(self):
        """WARNING для дискриминанта < 0"""
        with self.assertRaises(ValueError) as context:
            solve_quadratic(1, 1, 1)  # d = -3
        
        self.assertIn("WARNING", str(context.exception))
    
    def test_error_invalid_data(self):
        """ERROR для некорректных данных"""
        with self.assertRaises(TypeError):
            solve_quadratic("abc", 2, 3)
    
    def test_critical_impossible_situation(self):
        """CRITICAL для полностью невозможной ситуации"""
        with self.assertRaises(ValueError) as context:
            solve_quadratic(0, 0, 5)
        
        self.assertIn("CRITICAL", str(context.exception))
```

## Доп. тесты для файлового логирования

```python

import os
import logging

class TestFileLogging(unittest.TestCase):
    """Тесты логирования"""
    
    def setUp(self):
        # Удаляем старый лог если существует
        if os.path.exists('currency.log'):
            os.remove('currency.log')
        
        # Получаем логгер для файла
        self.file_logger = logging.getLogger("currency_file")
        self.file_logger.setLevel(logging.INFO)
        
        # Настраиваем файловый обработчик
        file_handler = logging.FileHandler('currency.log', encoding='utf-8')
        file_handler.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        self.file_logger.addHandler(file_handler)
    
    def test_file_logging_works(self):
        """Проверка записи логов в файл"""
        @logger(handle=self.file_logger)
        def test_func():
            return "test"
        test_func()
        
        # Проверяем, что файл создался
        self.assertTrue(os.path.exists('currency.log'))
        
        # Проверяем содержимое файла
        with open('currency.log', 'r', encoding='utf-8') as f:
            logs = f.read()
            self.assertIn("currency_file", logs)
            self.assertIn("INFO", logs)
            self.assertIn("test_func", logs)
    
    def tearDown(self):
        # Закрываем обработчики и удаляем файл
        for handler in self.file_logger.handlers[:]:
            handler.close()
            self.file_logger.removeHandler(handler)
        
        if os.path.exists('currency.log'):
            os.remove('currency.log')
```

